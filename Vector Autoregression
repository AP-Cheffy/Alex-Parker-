rm(list = ls())
library(ggplot2)
library(stats)
library(reshape2)
library(matrixStats)
library(compiler)
library(tseries)
library(standardize)
library(arrayhelpers)
library(matrixcalc)
#Import Data

#Y is defined in the recursive order _---- Please Update Accordingly
Yraw <- cbind(dsr,dlr,dex)
class(Yraw) <- "numeric"
Y <- scale(Yraw)
#########################
########################
M <- ncol(Yraw)
L <- nrow(Y)

# Lag Order, Calibrate, etc..
p = 4
n = length(Y)
h = 16 # IRF Horizon

varndxv <- c(M,1,p) # For State Space Structure 

# Create Lag Matrix Function For Y_t-1, Y_t-2...... 
# Y is [T x M]. xlag is [T x (Mp)]
Y_l <- function(X,lag)
{
  p <- lag
  X <- as.matrix(X)
  Q <- nrow(X)
  N <- ncol(X)
  Xlag <- matrix(0,Q,p*N)
  for (ii in 1:p){
    Xlag[(p+1):Q,(N*(ii-1)+1):(N*ii)]=X[(p+1-ii):(Q-ii),(1:N)]
  }
  return(Xlag)
}
var_companion_matrix <- function(Beta_,varndxv){
  nn <- varndxv[[1]]
  nd <- varndxv[[2]]
  nl <- varndxv[[3]]
  
  nkk <- nn*nl+nd
  
  Jm <- matrix(0,nkk,nn)
  Jm[1:nn,1:nn] <- diag(nn)
  if (nd==1){
    MM <- rbind(t(Beta_),cbind(diag((nl-1)*nn), matrix(0,(nl-1)*nn,nn+1)),c(matrix(0,1,nn*nl),1))
  }else{
    MM <- rbind(t(Beta_),cbind(diag((nl-1)*nn), matrix(0,(nl-1)*nn,nn)))
  }
  return(list(MM=MM,Jm=Jm))
} 

# Apply Function for Y_L, Y is 
Xlag <- Y_l(Y,p)
Y <- Y[(p+1):nrow(Y),,drop=FALSE]
X <- cbind(Xlag[(p+1):nrow(Xlag),],1)
 
# For SIGMA
K <- ncol(X)
O <- nrow(Y)
FL <- nrow(X)
# Estimate VAR by OLS
OLSReg <- function(X,Y){
  A <- solve(t(X) %*% X) %*% t(X)%*%Y
  nA <- ncol(A)
  E <- Y - X %*% A
  MaxE <- max(E)
  MinE <- min(E)
  Ehat <- (E - MaxE)/(MaxE - MinE)
# Normalize Residuals Between 0 or 1   
  Sigma2 <- t(Ehat)%*%Ehat/(L-p-p*M-1)
  Sigma00 <- matrix(0,nA,nA)
  Sigma00[1:M,1:M] <- Sigma2
  return(list(A=A,ehat=Ehat,Sigma2=Sigma2))
}
VAR_Est <- OLSReg(X,Y)

A <- VAR_Est$A 
ehat <-VAR_Est$ehat
Z <- nrow(ehat)
Int <- VAR_Est$V
mu <- VAR_Est$mean
Sigma2 <- VAR_Est$Sigma2
# Wrong Order - Upper Triangle Make Lower Triangle Apply Cholesky Factorization
B0 <- solve(t(chol((Sigma2))))

SS <- var_companion_matrix(A,varndxv)
JM <- SS$Jm
MM <- SS$MM

# Rescale A - Create Phi Array, purpose is to create a matrix for each lag p 
phi_array <- array(0,c(M,M,p))
for (k in 1:p){
  phi_array[,,k] <- t(A[((k-1)*M+1):(k*M),])
  
}

# Impulse Response Function 

irf <- function(B,smat,nstep){

### By:             As emerges from rfvar, neqn x nvar x lags array of rf VAR coefficients.
### smat:           nshock x nvar matrix of initial shock vectors.  To produce "orthogonalized
###                 impulse responses" it should have the property that crossprod(t(smat))=sigma,
###                 where sigma is the Var(u(t)) matrix and u(t) is the rf residual vector.  One
###                 way to get such a smat is to set smat=t(chol(sigma)).  To get the smat
###                 corresponding to a different ordering, use
###                 smat = t(chol(P %*% Sigma %*% t(P)) %*% P), where P is a permutation matrix.
###                 To get impulse responses for a structural VAR in the form A(L)y=eps, with
###                 Var(eps)=I, use B(L)=-A_0^(-1)A_+(L) (where A_+ is the coefficients on strictly
###                 positive powers of L in A), smat=A_0^(-1).
###                 In general, though, it is not required that smat be invertible.
### response:       nvar x nshocks x nstep array of impulse responses.
###
### Code written by Christopher Sims, based on 6/03 matlab code.  This version 3/27/04.
### Added dimension labeling, 8/02/04.
  
    ##-----debug--------
    ##browser()
    ##------------------
    neq <- dim(B)[1]
    nvar <- dim(B)[2]
    lags <- dim(B)[3]
    dimnB <- dimnames(B)
    if(dim(smat)[2] != dim(B)[2]) stop("B and smat conflict on # of variables")
    response <- array(0,dim=c(neq,nvar,nstep+lags-1));
    response[ , , lags] <- smat
    response <- aperm(response, c(1,3,2))
    irhs <- 1:(lags*nvar)
    ilhs <- lags * nvar + (1:nvar)
    response <- matrix(response, ncol=neq)
    B <- B[, , seq(from=lags, to=1, by=-1)]  #reverse time index to allow matrix multiply instead of loop
    B <- matrix(B,nrow=nvar)
    for (it in 1:(nstep-1)) {
      #browser()
      response[ilhs, ] <- B %*% response[irhs, ]
      irhs <- irhs + nvar
      ilhs <- ilhs + nvar
    }
    ## for (it in 2:nstep)
##       {
##         for (ilag in 1:min(lags,it-1))
##           response[,,it] <- response[,,it]+B[,,ilag] %*% response[,,it-ilag]
##       }
    dim(response) <- c(nvar, nstep + lags - 1, nvar)
    response <- aperm(response[ , -(1:(lags-1)), ], c(1, 3, 2)) #drop the zero initial conditions; array in usual format
    dimnames(response) <- list(dimnB[[1]], dimnames(smat)[[2]], NULL)
    ## dimnames(response)[2] <- dimnames(smat)[1]
    ## dimnames(response)[1] <- dimnames(B)[2]
    return(response)
}
irfresults <- irf(B = phi_array,smat = B0,nstep = h)

####################################################################################
# - Extract response for each variable - This tedious, for the time being 
# - Then add back into new irfstorage with horizon sequence for analysis of impulse response functions
######################################################################################
# Shocks From Variable 1
one_on_1<- irfresults[1,1,]
one_on_2 <-irfresults[1,2,]
one_on_3 <- irfresults[1,3,]
# Shocks From Variable 2
two_on_1<- irfresults[2,1,]
two_on_2 <-irfresults[2,2,]
two_on_3 <- irfresults[2,3,]
# Shocks From Variable 3
three_on_1<- irfresults[3,1,]
three_on_2 <-irfresults[3,2,]
three_on_3 <- irfresults[3,3,]


Shocks_Storage = cbind.data.frame(one_on_1,one_on_2,one_on_3,two_on_1,two_on_2,two_on_3,
                                  three_on_1,three_on_2,three_on_3)
Shocks_Storage <- as.matrix(Shocks_Storage)
L_L= ncol(Shocks_Storage)
### % VAR bootstrap Confidence Intervals similar to Kilian & Lütkepohl (2017)
# Set Initial Conditions and Storage Matrixes 
set.seed(12345)
reps <- 2000
Yb <- X%*%A
Irfstor <- matrix(0,reps,(h)*(L_L))
namessr <- rep(c('one_on_1','one_on_2','one_on_3','two_on_1','two_on_2','two_on_3'
                 ,'three_on_1','three_on_2','three_on_3'),times=16)
colnames(Irfstor) <- namessr
Ur <- matrix(0,M*p,L-p)

## Bootstrap Algorithm - see Kilian & Lütkepohl for details 
bootstrap <- function(Yb,ehat,reps,p,h,Ur,Irfstor){
for (i in 1:reps){
    # Resample Errors With Replacement - # Centered Residuals 
    Ur <- sample(ehat,replace = TRUE)
    # generate Ybar 
    IL <- Yb + Ur
    I <- ncol(IL)

    H <- Y_l(IL,p)
    Y <- IL[(p+1):nrow(IL),,drop=FALSE]
    X <- cbind(H[(p+1):nrow(H),],1)
    
    # Augment OLS Function for Bootstrap
    Boot_OLS <- function(X,Y){
      A <- solve(t(X) %*% X) %*% t(X)%*%Y
      nA <- ncol(A)
      E <- Y - X %*% A
      MeanE <- mean(E)
      Sigma2 <- t(E)%*%E/(L-p-p*M-1)
      Sigma00 <- matrix(0,nA,nA)
      Sigma00[1:I,1:I] <- Sigma2
      # Wrong Order - Upper Triangle Make Lower Triangle Apply Cholesky Factorization
      B0 <- solve(t(chol((Sigma2))))
      
      return(list(A=A,ehat=E,B0=B0,mean=MeanE,Sigma2=Sigma2))
    }
    
    VAR_Boot <- Boot_OLS(X,Y)
    A_b <- VAR_Boot$A
    B0_b <- VAR_Boot$B0
    
    phi_array_b <- array(0,c(I,I,p))
    for (k in 1:p){
      phi_array_b[,,k] <- t(A_b[((k-1)*M+1):(k*M),])
      }
    irfresults_b <- irf(B = phi_array_b,smat = B0_b,nstep = h)
    
    # Shocks From Variable 1
    one_on_1<- irfresults_b[1,1,] 
    one_on_2 <-irfresults_b[1,2,]
    one_on_3 <- irfresults_b[1,3,]
    # Shocks From Variable 2
    two_on_1<- irfresults_b[2,1,]
    two_on_2 <-irfresults_b[2,2,]
    two_on_3 <- irfresults_b[2,3,]
    # Shocks From Variable 3
    three_on_1<- irfresults_b[3,1,]
    three_on_2 <-irfresults_b[3,2,]
    three_on_3 <- irfresults_b[3,3,]
    
      
    Shocks_Storage_b = cbind.data.frame(one_on_1,one_on_2,one_on_3,two_on_1,two_on_2,two_on_3,
                                      three_on_1,three_on_2,three_on_3)
    Shocks_Storage_b <- as.matrix(Shocks_Storage_b)
    # Store Responses 
    Irfstor[i,] <- Shocks_Storage_b
    
  }
  return(list(IRF=Irfstor))
} 
results <- bootstrap(Yb,ehat,reps,p,h,Ur,Irfstor)

#######
# - Break Apart# 
######
#Error bands <- colQuantiles(,probs = c(0.95,0.05))
 


## Forecast Error Decomposition - similar to Ambrogio Cesa-Bianchi (2015)
# - Define Variables 

MSE <- array(0,c(M,M,h))
MSE_t <- array(0,c(M,M,h))



