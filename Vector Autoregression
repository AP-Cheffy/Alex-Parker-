

rm(list = ls())
library(ggplot2)
library(stats)
library(reshape2)
library(matrixStats)
library(compiler)
library(tseries)
library(standardize)
#Import Data
termstr <- read.csv("/Users/geoffreyaparker/Documents/R&Python&Matlab/R Code/TERM_STRUCTURE.csv",header = TRUE, na.strings = "")
head(termstr)
sr <- as.vector(termstr[,"X3MBR"])
lr <-  as.vector((termstr[,"X10YBR"]))
ex <-  as.vector((termstr[,"ExCan"]))
crd <- as.vector(log((termstr[,"CrVL"])))
cpi <- as.vector((termstr[,"CPI"]))
#Is Stationary?
adf.test(sr)
adf.test(lr)
adf.test(ex)
adf.test(crd)
adf.test(cpi)
# Taking First Differenece (REMOVE ANY CHANCE OF COINTEGRATION)
dsr <- diff(sr)
dlr <- diff(lr)
dex <- diff(ex)
dcrd <- diff(crd)
pr <- diff(cpi)

#Y is defined in the recursive order _---- Please Update Accordingly
Yraw <- cbind(dsr,dlr,dex,dcrd,pr)
class(Yraw) <- "numeric"
Y <- Yraw 
M <- ncol(Yraw)
L <- nrow(Y)
# Lag Order, Calibrate, etc..
p = 4
n = length(Y)
h = 16 # IRF Horizon

varndxv <- c(M,1,p) # For State Space Structure 

# Create Lag Matrix Function For Y_t-1, Y_t-2...... 
# Y is [T x M]. ylag is [T x (Mp)]
Y_l <- function(X,lag)
{
  p <- lag
  X <- as.matrix(X)
  Q <- nrow(X)
  N <- ncol(X)
  Xlag <- matrix(0,Q,p*N)
  for (ii in 1:p){
    Xlag[(p+1):Q,(N*(ii-1)+1):(N*ii)]=X[(p+1-ii):(Q-ii),(1:N)]
  }
  return(Xlag)
}
var_companion_matrix <- function(Beta_,varndxv){
  #Beta_ <- A_draw
  nn <- varndxv[[1]]
  nd <- varndxv[[2]]
  nl <- varndxv[[3]]
  
  nkk <- nn*nl+nd
  
  Jm <- matrix(0,nkk,nn)
  Jm[1:nn,1:nn] <- diag(nn)
  if (nd==1){
    MM <- rbind(t(Beta_),cbind(diag((nl-1)*nn), matrix(0,(nl-1)*nn,nn+1)),c(matrix(0,1,nn*nl),1))
  }else{
    MM <- rbind(t(Beta_),cbind(diag((nl-1)*nn), matrix(0,(nl-1)*nn,nn)))
  }
  return(list(MM=MM,Jm=Jm))
} 

# Apply Function for Y_L, Y is 
Xlag <- Y_l(Y,p)
Y <- Y[(p+1):nrow(Y),,drop=FALSE]
X <- cbind(Xlag[(p+1):nrow(Xlag),],1)

# For SIGMA
K <- ncol(X)
# Estimate VAR by OLS 
A <- solve(t(X) %*% X) %*% t(X)%*%Y
nA <- ncol(A)
SS <- var_companion_matrix(A,varndxv)
# Residuals
E <- Y - X %*% A
Sigma2 <- t(E)%*%E/(L-p-p*M-1)
Sigma00 <- matrix(0,nA,nA)
Sigma00[1:M,1:M] <- Sigma2
# Wrong Order - Upper Triangle Make Lower Triangle Apply Cholesky Factorization
B0 <- solve(t(chol((Sigma2))))

# Rescale A - Drop Last Row (Beta Coeff for Intercept Dropped)
V <- A[-c(21),]
# Impulse Response Function 
impulsdtrf <- function(L,smat,nstep)
### By:             As emerges from rfvar, neqn x nvar x lags array of rf VAR coefficients.
### smat:           nshock x nvar matrix of initial shock vectors.  To produce "orthogonalized
###                 impulse responses" it should have the property that crossprod(t(smat))=sigma,
###                 where sigma is the Var(u(t)) matrix and u(t) is the rf residual vector.  One
###                 way to get such a smat is to set smat=t(chol(sigma)).  To get the smat
###                 corresponding to a different ordering, use
###                 smat = t(chol(P %*% Sigma %*% t(P)) %*% P), where P is a permutation matrix.
###                 To get impulse responses for a structural VAR in the form A(L)y=eps, with
###                 Var(eps)=I, use B(L)=-A_0^(-1)A_+(L) (where A_+ is the coefficients on strictly
###                 positive powers of L in A), smat=A_0^(-1).
###                 In general, though, it is not required that smat be invertible.
### response:       nvar x nshocks x nstep array of impulse responses.
###
### Code written by Christopher Sims, based on 6/03 matlab code.  This version 3/27/04.
### Added dimension labeling, 8/02/04.
  {
    ##-----debug--------
    ##browser()
    ##------------------
    neq <- dim(B)[1]
    nvar <- dim(B)[2]
    lags <- dim(B)[3]
    dimnB <- dimnames(B)
    if(dim(smat)[2] != dim(B)[2]) stop("B and smat conflict on # of variables")
    response <- array(0,dim=c(neq,nvar,nstep+lags-1));
    response[ , , lags] <- smat
    response <- aperm(response, c(1,3,2))
    irhs <- 1:(lags*nvar)
    ilhs <- lags * nvar + (1:nvar)
    response <- matrix(response, ncol=neq)
    B <- B[, , seq(from=lags, to=1, by=-1)]  #reverse time index to allow matrix mult instead of loop
    B <- matrix(B,nrow=nvar)
    for (it in 1:(nstep-1)) {
      #browser()
      response[ilhs, ] <- B %*% response[irhs, ]
      irhs <- irhs + nvar
      ilhs <- ilhs + nvar
    }
    ## for (it in 2:nstep)
##       {
##         for (ilag in 1:min(lags,it-1))
##           response[,,it] <- response[,,it]+B[,,ilag] %*% response[,,it-ilag]
##       }
    dim(response) <- c(nvar, nstep + lags - 1, nvar)
    response <- aperm(response[ , -(1:(lags-1)), ], c(1, 3, 2)) #drop the zero initial conditions; array in usual format
    dimnames(response) <- list(dimnB[[1]], dimnames(smat)[[2]], NULL)
    ## dimnames(response)[2] <- dimnames(smat)[1]
    ## dimnames(response)[1] <- dimnames(B)[2]
    return(response)
  }
